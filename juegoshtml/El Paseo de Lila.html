<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El Vuelo de Lila</title>
    <style>
        body {
            background-color: #222222;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; margin: 0; font-family: 'Verdana', 'Geneva', sans-serif;
        }

        #gameTitle {
            color: #E0E0E0; margin-bottom: 15px; font-size: 2.5em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #gameContainer {
            width: 800px; height: 500px;
            background: linear-gradient(to bottom, #87CEFA 0%, #B0E0E6 65%, #90EE90 65%, #90EE90 100%);
            border: 5px solid #004d00; position: relative; overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .cloud {
            position: absolute; background-color: rgba(255, 255, 255, 0.75);
            border-radius: 50%; opacity: 0.7; pointer-events: none; z-index: 0;
        }
        .cloud.c1 { width: 100px; height: 60px; top: 40px; animation: moveCloud1 30s linear infinite; }
        .cloud.c2 { width: 150px; height: 80px; top: 90px; animation: moveCloud2 40s linear infinite 3s; }
        .cloud.c3 { width: 80px; height: 50px; top: 60px; animation: moveCloud3 25s linear infinite 7s; }
        .cloud::before, .cloud::after { content: ''; position: absolute; background-color: rgba(255, 255, 255, 0.75); border-radius: 50%; }
        .cloud.c1::before { width: 60px; height: 60px; top: -20px; left: 20px; }
        .cloud.c1::after { width: 70px; height: 70px; top: -10px; right: 15px; }
        .cloud.c2::before { width: 90px; height: 90px; top: -30px; left: 30px; }
        .cloud.c2::after { width: 80px; height: 80px; top: -20px; right: 25px; }
        @keyframes moveCloud1 { from { left: -120px; } to { left: 820px; } }
        @keyframes moveCloud2 { from { left: -170px; } to { left: 820px; } }
        @keyframes moveCloud3 { from { left: -100px; } to { left: 820px; } }

        #ground {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 70px;
            background-color: #556B2F; border-top: 4px solid #4A5D23; z-index: 1;
        }

        .flower {
            position: absolute; width: 20px; height: 30px; bottom: 70px; z-index: 0;
        }
        .flower .stem { width: 3px; height: 20px; background-color: #3CB371; position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); }
        .flower .petal-center { width: 8px; height: 8px; background-color: #FFD700; border-radius: 50%; position: absolute; top: 0; left: 50%; transform: translateX(-50%); }
        .flower .petal { width: 10px; height: 10px; border-radius: 50% 50% 0 0; position: absolute; top: -3px; left: 50%; transform-origin: bottom center; }
        .flower .p1 { transform: translateX(-50%) rotate(0deg); } .flower .p2 { transform: translateX(-50%) rotate(72deg); }
        .flower .p3 { transform: translateX(-50%) rotate(144deg); } .flower .p4 { transform: translateX(-50%) rotate(216deg); }
        .flower .p5 { transform: translateX(-50%) rotate(288deg); }

        #lila {
            width: 100px; height: auto; position: absolute; left: 60px;
            user-select: none; -webkit-user-drag: none; z-index: 10;
            animation: lilaBobbing 0.35s ease-in-out infinite;
        }
        #lila.jumping, #lila.double-jumping { animation: none; transform: translateY(-2px) rotate(-3deg); }
        #lila.double-jumping { transform: translateY(-5px) rotate(-7deg) scale(1.05); }
        @keyframes lilaBobbing {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-5px) rotate(1deg); }
        }

        .game-element {
            position: absolute;
            background-repeat: no-repeat;
            background-size: contain;
            background-position: center bottom; /* Alinea la imagen al fondo del div */
            z-index: 5;
        }

        .obstacle.hydrant {
            width: 60px;  /* Aumentado ~20% desde 50px */
            height: 90px; /* Aumentado ~20% desde 75px */
            background-image: url('hydrant.png');
        }
        .obstacle.bush {
            width: 96px;  /* Aumentado ~20% desde 80px */
            height: 66px; /* Aumentado ~20% desde 55px */
            background-image: url('bush.png');
        }

        .reward {
            z-index: 6;
            animation: rewardFloat 1.5s ease-in-out infinite alternate;
        }
        @keyframes rewardFloat {
            from { transform: translateY(0px); }
            to   { transform: translateY(-10px); }
        }

        .reward.bone {
            width: 52px;  /* Aumentado ~15% desde 45px */
            height: 35px; /* Aumentado ~15% desde 30px */
            background-image: url('bone.png');
        }
        .reward.wing {
            width: 58px;  /* Aumentado ~15% desde 50px */
            height: 46px; /* Aumentado ~15% desde 40px */
            background-image: url('wing.png');
        }

        #scoreDisplay {
            font-size: 28px; margin-top: 15px; color: #E0E0E0; font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.7);
        }

        #startScreen, #gameOverScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(20, 20, 20, 0.75); color: white; display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; z-index: 1000; backdrop-filter: blur(4px);
        }
        #startScreen h2, #gameOverScreen h2 { font-size: 50px; margin-bottom: 25px; text-shadow: 2px 2px 4px rgba(0,0,0,0.6); }
        #startScreen p, #gameOverScreen p { font-size: 24px; margin-bottom: 35px; line-height: 1.5; }
        #startScreen .jump-info { font-size: 18px; color: #cccccc; margin-top: -15px; margin-bottom: 25px; }
        #gameOverScreen button {
            padding: 16px 32px; font-size: 20px; color: #FFFFFF; background-color: #337ab7;
            border: none; border-bottom: 3px solid #286090; border-radius: 7px; cursor: pointer;
            transition: background-color 0.2s, transform 0.1s; text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        }
        #gameOverScreen button:hover { background-color: #286090; }
        #gameOverScreen button:active { transform: translateY(2px); border-bottom-width: 1px; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <h1 id="gameTitle">El Vuelo de Lila</h1>
    <div id="gameContainer">
        <div class="cloud c1"></div> <div class="cloud c2"></div> <div class="cloud c3"></div>
        <div id="ground"></div>
        <img id="lila" src="Lila.png" alt="Lila la perrita">

        <div id="startScreen">
            <h2>El Vuelo de Lila</h2>
            <p>Presiona ESPACIO o FLECHA ARRIBA<br>para Saltar y Empezar</p>
            <p class="jump-info">(Puedes hacer un segundo salto en el aire)</p>
        </div>
        <div id="gameOverScreen" class="hidden">
            <h2>¡Juego Terminado!</h2>
            <p id="finalScore">Puntuación Final: 0</p>
            <button id="restartButton">Reiniciar Juego</button>
        </div>
    </div>
    <div id="scoreDisplay">Puntuación: 0</div>

    <script>
        const gameContainer = document.getElementById('gameContainer');
        const lila = document.getElementById('lila');
        const ground = document.getElementById('ground');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');

        const GAME_WIDTH = gameContainer.offsetWidth;
        const GAME_HEIGHT = gameContainer.offsetHeight;
        const LILA_WIDTH = 100;
        const LILA_ASPECT_RATIO = 0.75;
        const LILA_HEIGHT = LILA_WIDTH * LILA_ASPECT_RATIO;

        const GROUND_HEIGHT = ground.offsetHeight;
        const LILA_INITIAL_Y = GROUND_HEIGHT;

        let score = 0;
        let gameSpeed = 4.5;
        let gameSpeedIncreaseFactor = 0.0004;
        let maxGameSpeed = 11;

        let lilaY = LILA_INITIAL_Y;
        let lilaVelocityY = 0;
        const GRAVITY = 0.75;
        const JUMP_STRENGTH = 16.5;
        const DOUBLE_JUMP_STRENGTH = 13.5;
        let jumpCount = 0;
        let isJumpingState = false;

        let obstacles = [];
        let rewards = [];
        let backgroundElements = []; // Solo para flores ahora

        let obstacleSpawnTimer = 0;
        const OBSTACLE_SPAWN_INTERVAL_MIN = 1900;
        const OBSTACLE_SPAWN_INTERVAL_MAX = 3300;
        let nextObstacleSpawn = getRandomInterval(OBSTACLE_SPAWN_INTERVAL_MIN, OBSTACLE_SPAWN_INTERVAL_MAX);

        let rewardSpawnTimer = 0;
        const REWARD_SPAWN_INTERVAL_MIN = 4000;
        const REWARD_SPAWN_INTERVAL_MAX = 7000;
        let nextRewardSpawn = getRandomInterval(REWARD_SPAWN_INTERVAL_MIN, REWARD_SPAWN_INTERVAL_MAX);

        let flowerSpawnTimer = 0;
        const FLOWER_INTERVAL_MIN = 2500;
        const FLOWER_INTERVAL_MAX = 5000;
        let nextFlowerSpawn = getRandomInterval(FLOWER_INTERVAL_MIN, FLOWER_INTERVAL_MAX);

        let gameStarted = false;
        let gameOver = false;
        let gameLoopInterval;
        let scoreInterval;

        function getRandomInterval(min, max) {
            return Math.random() * (max - min) + min;
        }

        function updateLilaVisualState() {
            lila.style.bottom = `${lilaY}px`;
            if (isJumpingState && lilaY > LILA_INITIAL_Y) {
                if (jumpCount === 1) lila.classList.add('jumping');
                else if (jumpCount === 2) lila.classList.add('double-jumping');
            } else {
                lila.classList.remove('jumping', 'double-jumping');
            }
        }

        function jump() {
            if (jumpCount < 2) {
                isJumpingState = true;
                jumpCount++;
                lilaVelocityY = (jumpCount === 1) ? JUMP_STRENGTH : DOUBLE_JUMP_STRENGTH;
                lila.classList.remove('jumping', 'double-jumping');
                if (jumpCount === 1) lila.classList.add('jumping');
                else if (jumpCount === 2) lila.classList.add('double-jumping');
            }
        }

        document.addEventListener('keydown', (event) => {
            if (!gameStarted && (event.code === 'Space' || event.key === 'ArrowUp')) {
                event.preventDefault(); startGame();
            } else if (gameStarted && !gameOver && (event.code === 'Space' || event.key === 'ArrowUp')) {
                event.preventDefault(); jump();
            }
        });
        gameContainer.addEventListener('touchstart', (event) => {
            event.preventDefault();
            if (!gameStarted) startGame();
            else if (gameStarted && !gameOver) jump();
        }, { passive: false });

        function createElement(type, category) {
            const element = document.createElement('div');
            element.classList.add('game-element', category, type);
            
            let elWidth, elHeight, elPoints = 0;
            // Las dimensiones se toman ahora del CSS
            const tempEl = document.createElement('div'); // Elemento temporal para obtener estilos computados
            tempEl.className = `game-element ${category} ${type}`;
            document.body.appendChild(tempEl); // Necesita estar en el DOM para getComputedStyle
            elWidth = parseFloat(getComputedStyle(tempEl).width);
            elHeight = parseFloat(getComputedStyle(tempEl).height);
            document.body.removeChild(tempEl);


            if (category === 'reward') {
                if (type === 'bone') { elPoints = 25; }
                else if (type === 'wing') { elPoints = 50; }
                // Posicionar recompensas en el aire
                const randomHeightOffset = Math.random() * 80 + 60; // Entre 60px y 140px sobre el suelo
                element.style.bottom = `${GROUND_HEIGHT + randomHeightOffset}px`;
            } else if (category === 'obstacle') {
                 element.style.bottom = `${GROUND_HEIGHT}px`;
            }
            
            element.style.width = `${elWidth}px`; // Redundante si ya está en CSS, pero bueno tenerlo
            element.style.height = `${elHeight}px`;// Redundante
            element.style.right = `-${elWidth}px`;
            element.dataset.points = elPoints;

            gameContainer.appendChild(element);
            if (category === 'obstacle') obstacles.push(element);
            else if (category === 'reward') rewards.push(element);
        }
        
        function createBackgroundElement(type) { // Ahora solo para flores
            if (type !== 'flower') return; // Salir si no es flor

            const element = document.createElement('div');
            element.dataset.type = type;
            let elSpeedMultiplier = 0.4; // Flores lentas

            element.classList.add('flower');
            const stem = document.createElement('div'); stem.className = 'stem';
            const petalCenter = document.createElement('div'); petalCenter.className = 'petal-center';
            element.appendChild(stem); element.appendChild(petalCenter);
            ['p1','p2','p3','p4','p5'].forEach(pClass => {
                const petal = document.createElement('div'); petal.className = `petal ${pClass}`;
                const colors = ['#FF69B4', '#FFFFE0', '#ADD8E6', '#FFB6C1', '#DA70D6'];
                petal.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                element.appendChild(petal);
            });
            element.style.right = '-30px';
            element.style.bottom = `${GROUND_HEIGHT + Math.random() * 10 - 5}px`;
            
            element.dataset.speedMultiplier = elSpeedMultiplier;
            gameContainer.insertBefore(element, lila);
            backgroundElements.push(element);
        }

        function updateGameElements(elementsArray, isObstacleOrReward) {
            for (let i = elementsArray.length - 1; i >= 0; i--) {
                const element = elementsArray[i];
                let currentRight = parseFloat(element.style.right);
                
                let speed = gameSpeed;
                if (!isObstacleOrReward && element.dataset.speedMultiplier) {
                    speed *= parseFloat(element.dataset.speedMultiplier);
                }
                currentRight += speed;
                element.style.right = `${currentRight}px`;

                if (isObstacleOrReward && checkCollision(lila, element)) {
                    if (element.classList.contains('obstacle')) {
                        endGame();
                        return;
                    } else if (element.classList.contains('reward')) {
                        score += parseInt(element.dataset.points) || 0;
                        updateScoreDisplay();
                        element.remove();
                        elementsArray.splice(i, 1);
                        continue;
                    }
                }

                const elementWidth = parseFloat(element.style.width);
                if (currentRight > GAME_WIDTH + elementWidth + 50) {
                    element.remove();
                    elementsArray.splice(i, 1);
                }
            }
        }

        function checkCollision(element1, element2) {
            const rect1 = element1.getBoundingClientRect();
            const rect2 = element2.getBoundingClientRect();
            const lilaToleranceVertical = LILA_HEIGHT * 0.15;
            const lilaToleranceHorizontal = LILA_WIDTH * 0.20;

            const lilaEffectiveRect = {
                top: rect1.top + lilaToleranceVertical,
                bottom: rect1.bottom - lilaToleranceVertical,
                left: rect1.left + lilaToleranceHorizontal,
                right: rect1.right - lilaToleranceHorizontal,
            };
            
            const itemTolerance = 2;

            return !(
                lilaEffectiveRect.right < rect2.left + itemTolerance ||
                lilaEffectiveRect.left > rect2.right - itemTolerance ||
                lilaEffectiveRect.bottom < rect2.top + itemTolerance ||
                lilaEffectiveRect.top > rect2.bottom - itemTolerance
            );
        }

        function updateScoreDisplay() {
            scoreDisplay.textContent = `Puntuación: ${Math.floor(score)}`;
        }

        function showGameOverScreen() {
            finalScoreDisplay.textContent = `Puntuación Final: ${Math.floor(score)}`;
            gameOverScreen.classList.remove('hidden');
        }

        function resetGame() {
            gameOver = false; gameStarted = false; score = 0;
            gameSpeed = 4.5; lilaY = LILA_INITIAL_Y; lilaVelocityY = 0;
            jumpCount = 0; isJumpingState = false;

            [obstacles, rewards, backgroundElements].forEach(arr => {
                arr.forEach(el => el.remove());
                arr.length = 0;
            });

            updateLilaVisualState(); updateScoreDisplay();
            gameOverScreen.classList.add('hidden'); startScreen.classList.remove('hidden');
            lila.style.animationPlayState = 'paused';
        }
        
        function startGame() {
            if (gameStarted) return;
            resetGame(); gameStarted = true;
            startScreen.classList.add('hidden'); lila.style.animationPlayState = 'running';

            const now = Date.now();
            obstacleSpawnTimer = now;
            nextObstacleSpawn = getRandomInterval(OBSTACLE_SPAWN_INTERVAL_MIN, OBSTACLE_SPAWN_INTERVAL_MAX);
            rewardSpawnTimer = now;
            nextRewardSpawn = getRandomInterval(REWARD_SPAWN_INTERVAL_MIN, REWARD_SPAWN_INTERVAL_MAX);
            
            flowerSpawnTimer = now; // Reiniciar timer de flores
            nextFlowerSpawn = getRandomInterval(FLOWER_INTERVAL_MIN, FLOWER_INTERVAL_MAX); // Reiniciar próximo spawn de flores


            if (gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameLoop, 1000 / 60);
            if (scoreInterval) clearInterval(scoreInterval);
            scoreInterval = setInterval(() => {
                if (!gameOver && gameStarted) {
                    score += gameSpeed / 15; updateScoreDisplay();
                }
            }, 100);
        }

        function endGame() {
            gameOver = true; gameStarted = false;
            showGameOverScreen(); lila.style.animationPlayState = 'paused';
        }

        function gameLoop() {
            if (gameOver) return;

            lilaVelocityY -= GRAVITY; lilaY += lilaVelocityY;
            if (lilaY <= LILA_INITIAL_Y) {
                lilaY = LILA_INITIAL_Y; lilaVelocityY = 0; jumpCount = 0; isJumpingState = false;
            }
            updateLilaVisualState();

            const currentTime = Date.now();

            if (currentTime - obstacleSpawnTimer > nextObstacleSpawn) {
                createElement(Math.random() < 0.5 ? 'hydrant' : 'bush', 'obstacle');
                obstacleSpawnTimer = currentTime;
                let dMin = Math.max(800, OBSTACLE_SPAWN_INTERVAL_MIN * (4.5 / gameSpeed));
                let dMax = Math.max(1500, OBSTACLE_SPAWN_INTERVAL_MAX * (4.5 / gameSpeed));
                nextObstacleSpawn = getRandomInterval(dMin, dMax);
            }
            if (currentTime - rewardSpawnTimer > nextRewardSpawn) {
                createElement(Math.random() < 0.6 ? 'bone' : 'wing', 'reward');
                rewardSpawnTimer = currentTime;
                let dMinR = Math.max(2000, REWARD_SPAWN_INTERVAL_MIN * (4.5 / gameSpeed));
                let dMaxR = Math.max(3500, REWARD_SPAWN_INTERVAL_MAX * (4.5 / gameSpeed));
                nextRewardSpawn = getRandomInterval(dMinR, dMaxR);
            }
            
            if (currentTime - flowerSpawnTimer > nextFlowerSpawn) {
                createBackgroundElement('flower');
                flowerSpawnTimer = currentTime;
                let dMinF = Math.max(1000, FLOWER_INTERVAL_MIN * (4.5 / gameSpeed));
                let dMaxF = Math.max(2000, FLOWER_INTERVAL_MAX * (4.5 / gameSpeed));
                nextFlowerSpawn = getRandomInterval(dMinF, dMaxF);
            }

            updateGameElements(obstacles, true);
            updateGameElements(rewards, true);
            updateGameElements(backgroundElements, false); // Actualizar flores

            if (gameSpeed < maxGameSpeed) gameSpeed += gameSpeedIncreaseFactor;
            if (gameStarted) lila.style.animationPlayState = 'running';
        }

        restartButton.addEventListener('click', resetGame);
        lilaY = LILA_INITIAL_Y; updateLilaVisualState(); updateScoreDisplay();
        lila.style.animationPlayState = 'paused';
    </script>
</body>
</html>